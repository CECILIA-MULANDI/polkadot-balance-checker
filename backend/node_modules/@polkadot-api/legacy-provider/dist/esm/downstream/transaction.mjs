import { createOpaqueToken } from '../utils/create-opaque-token.mjs';
import { catchError, concat, timer, takeUntil, ignoreElements } from 'rxjs';

const transactionMethods = Object.fromEntries(
  ["broadcast", "stop"].map((key) => [key, `transaction_v1_${key}`])
);
const createTransactionFns = (upstream, reply) => {
  const ongoing = /* @__PURE__ */ new Map();
  const result = (rId, method, args) => {
    if (method === transactionMethods.stop) {
      const [token] = args;
      ongoing.get(token)?.unsubscribe();
      ongoing.delete(token);
      reply(rId, null);
    } else if (method === transactionMethods.broadcast) {
      const token = createOpaqueToken();
      ongoing.set(
        token,
        upstream.obsRequest("author_submitExtrinsic", args).pipe(
          // We want to make sure that we keep on retrying if there
          // are errors with the `author_submitExtrinsic` request
          catchError((_, source) => concat(timer(5e3), source)),
          // This logic ensures that the subscription dies if an
          // upstream error (like the client being destroyed) takes place
          takeUntil(
            upstream.finalized$.pipe(
              ignoreElements(),
              catchError(() => {
                ongoing.delete(token);
                return [null];
              })
            )
          )
        ).subscribe()
      );
      reply(rId, token);
    } else {
      throw null;
    }
  };
  result.stop = () => {
    ongoing.forEach((s) => s.unsubscribe());
    ongoing.clear();
  };
  return result;
};

export { createTransactionFns, transactionMethods };
//# sourceMappingURL=transaction.mjs.map
