import { createOpaqueToken } from '../utils/create-opaque-token.mjs';
import { map, take, finalize } from 'rxjs';
import { areItemsValid, getStg$ } from './storage.mjs';
import { getMsgFromErr } from '../utils/message-from-error.mjs';

const archiveMethods = Object.fromEntries(
  [
    "body",
    "call",
    "finalizedHeight",
    "genesisHash",
    "hashByHeight",
    "header",
    "stopStorage",
    "storage"
  ].map((key) => [key, `archive_v1_${key}`])
);
const createArchive = (upstream, reply, err, notification) => {
  const stgSubscriptions = /* @__PURE__ */ new Map();
  const stg = (reply2, at, items) => {
    const subId = createOpaqueToken();
    reply2(subId);
    const innerNotifiaction = (result2) => {
      notification("archive_v1_storageEvent", subId, result2);
    };
    const subscription = getStg$(upstream, at, items).pipe(
      finalize(() => {
        stgSubscriptions.delete(subId);
      })
    ).subscribe(
      (items2) => {
        items2.forEach(
          (item) => innerNotifiaction({ event: "storage", ...item })
        );
      },
      (e) => {
        innerNotifiaction({ event: "storageError", error: getMsgFromErr(e) });
      },
      () => {
        innerNotifiaction({ event: "storageDone" });
      }
    );
    if (!subscription.closed) stgSubscriptions.set(subId, subscription);
  };
  const result = (rId, name, params) => {
    const innerReply = (value) => {
      reply(rId, value);
    };
    const obsReply = (input) => {
      input.subscribe({
        next: innerReply,
        error: (e) => {
          err(rId, e.code ?? -1, getMsgFromErr(e));
        }
      });
    };
    const [firstArg, secondArg, thirdArg] = params;
    switch (name) {
      case archiveMethods.body:
        return obsReply(upstream.getBody(firstArg));
      case archiveMethods.call:
        return obsReply(
          upstream.runtimeCall(firstArg, secondArg, thirdArg).pipe(map((value) => ({ success: true, value })))
        );
      case archiveMethods.finalizedHeight:
        return obsReply(
          upstream.finalized$.pipe(
            map((x) => x.number),
            take(1)
          )
        );
      case archiveMethods.genesisHash:
        return obsReply(upstream.genesisHash);
      case archiveMethods.hashByHeight:
        return obsReply(upstream.getBlockHash$(firstArg));
      case archiveMethods.header:
        return obsReply(
          upstream.getHeader$(firstArg).pipe(map((h) => h.header))
        );
      case archiveMethods.stopStorage: {
        const sub = stgSubscriptions.get(firstArg);
        return sub ? sub.unsubscribe() : err(rId, -32602, "Invalid args");
      }
      case archiveMethods.storage:
        return areItemsValid(secondArg) ? stg(innerReply, firstArg, secondArg) : err(rId, -32602, "Invalid args");
    }
    throw null;
  };
  result.stop = () => {
    [...stgSubscriptions].forEach(([, s]) => s.unsubscribe());
    stgSubscriptions.clear();
  };
  return result;
};

export { archiveMethods, createArchive };
//# sourceMappingURL=archive.mjs.map
