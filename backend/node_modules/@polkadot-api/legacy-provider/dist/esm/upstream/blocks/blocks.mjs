import { Subject, concatMap, of, filter, debounceTime, take, share, takeWhile, merge, map, mergeMap, delay, concat, tap } from 'rxjs';
import { shareLatest } from '../../utils/share-latest.mjs';

const getBlocks = ({
  allHeads$,
  finalized$: finalizedWire$,
  getHeader$,
  hasher$,
  getRecursiveHeader
}) => {
  const connectedBlocks = {
    blocks: /* @__PURE__ */ new Map(),
    prevFin: "",
    finalized: "",
    best: ""
  };
  const getTree = (root, result = []) => {
    result.push(root);
    connectedBlocks.blocks.get(root).children.forEach((c) => {
      getTree(c, result);
    });
    return result;
  };
  const addBlock = (block) => {
    const { blocks } = connectedBlocks;
    const { hash, parent } = block;
    const me = {
      ...block,
      children: /* @__PURE__ */ new Set(),
      usages: /* @__PURE__ */ new Set()
    };
    blocks.set(hash, me);
    blocks.get(parent)?.children.add(hash);
    return me;
  };
  const setBestFromFinalized = () => {
    connectedBlocks.best = connectedBlocks.finalized;
    let bestHeight = 0;
    const { finalized, blocks } = connectedBlocks;
    getTree(finalized).map((x) => blocks.get(x)).forEach((x) => {
      if (x.number > bestHeight) {
        bestHeight = x.number;
        connectedBlocks.best = x.hash;
      }
    });
  };
  const pendingBlocks = /* @__PURE__ */ new Map();
  const trimPending = (root) => {
    const desc = [...pendingBlocks.get(root).children];
    pendingBlocks.delete(root);
    desc.forEach(trimPending);
  };
  const getPendingTree = (root, result = []) => {
    const me = pendingBlocks.get(root);
    if (!me.header) return result;
    result.push(me.header);
    me.children.forEach((c) => {
      getPendingTree(c, result);
    });
    return result;
  };
  const _newBlocks$ = new Subject();
  const onError = (e) => _newBlocks$.error(e);
  const _finalized$ = finalizedWire$.pipe(
    concatMap((header, idx) => {
      const { hash } = header;
      if (!idx) {
        addBlock(header);
        connectedBlocks.finalized = connectedBlocks.best = header.hash;
      }
      return connectedBlocks.blocks.has(hash) ? of(hash) : _newBlocks$.pipe(
        filter((x) => x === hash),
        // some of the following blocks could be prunned b/c of this finalized event.
        // So, we have to make sure that this "batch" of _newBlocks has been flushed.
        debounceTime(0),
        take(1)
      );
    }),
    share()
  );
  allHeads$.subscribe((header) => {
    const { parent, hash } = header;
    if (connectedBlocks.blocks.has(parent)) {
      addBlock(header);
      _newBlocks$.next(hash);
    } else {
      pendingBlocks.set(hash, {
        hash: header.hash,
        header,
        children: /* @__PURE__ */ new Set()
      });
      if (!pendingBlocks.has(parent)) {
        pendingBlocks.set(parent, {
          hash: parent,
          header: null,
          children: /* @__PURE__ */ new Set()
        });
        getRecursiveHeader(parent).pipe(
          takeWhile((result) => {
            let me = pendingBlocks.get(result.hash);
            if (!me) return false;
            me.header = result;
            const finalized = connectedBlocks.blocks.get(
              connectedBlocks.finalized
            );
            if (finalized && result.number <= finalized.number) {
              while (pendingBlocks.has(me.header?.parent ?? ""))
                me = pendingBlocks.get(me.header.parent);
              trimPending(me.hash);
              return false;
            }
            if (connectedBlocks.blocks.has(result.parent)) {
              let target = connectedBlocks.blocks.get(result.parent);
              const diff = target.number - finalized.number;
              for (let i = 0; i < diff; i++) {
                const nextTarget = connectedBlocks.blocks.get(target.parent);
                if (!nextTarget) break;
                target = nextTarget;
              }
              if (target === finalized) {
                const pendingOnes = getPendingTree(result.hash);
                pendingOnes.forEach((h) => {
                  pendingBlocks.delete(h.hash);
                  addBlock(h);
                  _newBlocks$.next(h.hash);
                });
              } else trimPending(result.hash);
              return false;
            }
            const pendingParent = pendingBlocks.get(result.parent);
            if (pendingParent) {
              pendingParent.children.add(result.hash);
              return false;
            }
            pendingBlocks.set(result.parent, {
              hash: result.parent,
              header: null,
              children: /* @__PURE__ */ new Set([result.hash])
            });
            return true;
          })
        ).subscribe({ error: onError });
      }
      pendingBlocks.get(parent).children.add(hash);
    }
  }, onError);
  const getFinalizedEvent = () => {
    const prunedBlockHashes = [];
    const finalizedBlockHashes = [];
    const { blocks, finalized, prevFin } = connectedBlocks;
    let current = blocks.get(finalized);
    let prev = blocks.get(current.parent);
    while (prev) {
      finalizedBlockHashes.push(current.hash);
      prev.children.forEach((c) => {
        if (c !== current.hash) getTree(c, prunedBlockHashes);
      });
      current = prev;
      if (current.hash === prevFin) break;
      prev = blocks.get(current.parent);
    }
    finalizedBlockHashes.reverse();
    return { event: "finalized", prunedBlockHashes, finalizedBlockHashes };
  };
  let activeSubscriptions = /* @__PURE__ */ new Set();
  const getNewBlockEvent = (blockHash) => {
    const block = connectedBlocks.blocks.get(blockHash);
    activeSubscriptions.forEach((subId) => {
      block.usages.add(subId);
    });
    return {
      event: "newBlock",
      blockHash,
      parentBlockHash: block.parent,
      newRuntime: block.hasUpgrade ? {} : null
    };
  };
  const tryRemove = (blockHash, up) => {
    const { blocks } = connectedBlocks;
    const block = blocks.get(blockHash);
    if (!block || block.usages.size > 0) return;
    const { parent, children } = block;
    if (up !== true) children.forEach((c) => tryRemove(c, false));
    if (up !== false) tryRemove(parent, true);
    if (!blocks.has(parent) || !block.children.size) {
      blocks.get(parent)?.children.delete(blockHash);
      blocks.delete(blockHash);
    }
  };
  const updates$ = merge(
    _newBlocks$.pipe(
      map((hash) => ({
        type: "new",
        value: connectedBlocks.blocks.get(hash)
      }))
    ),
    _finalized$.pipe(map((hash) => ({ type: "fin", value: hash })))
  ).pipe(
    mergeMap((x) => {
      if (x.type === "new") {
        const block = x.value;
        const { hash } = block;
        addBlock(block);
        const result2 = [getNewBlockEvent(hash)];
        if (block.number > connectedBlocks.blocks.get(connectedBlocks.best).number) {
          connectedBlocks.best = hash;
          result2.push({ event: "bestBlockChanged", bestBlockHash: hash });
        }
        return result2;
      }
      connectedBlocks.prevFin = connectedBlocks.finalized;
      connectedBlocks.finalized = x.value;
      let prevBest = connectedBlocks.best;
      setBestFromFinalized();
      const result = [getFinalizedEvent()];
      if (prevBest !== connectedBlocks.best)
        result.unshift({
          event: "bestBlockChanged",
          bestBlockHash: connectedBlocks.best
        });
      return result;
    }),
    share()
  );
  const ready$ = _newBlocks$.pipe(
    filter(() => !pendingBlocks.size),
    take(1),
    delay(0),
    // allows for the first bunch of _newBlock events to settle on the latest updated state
    map(() => null),
    shareLatest
  );
  const finalized$ = ready$.pipe(
    mergeMap(
      () => _finalized$.pipe(
        map((hash) => connectedBlocks.blocks.get(hash))
      )
    ),
    shareLatest
  );
  merge(updates$, finalized$).subscribe({
    error: onError
  });
  const upstream = (subId) => {
    const getInitialized = () => {
      const { blocks, finalized } = connectedBlocks;
      const finalizedBlockHashes = [];
      let current = blocks.get(finalized);
      while (current && finalizedBlockHashes.length < 10) {
        finalizedBlockHashes.push(current.hash);
        current.usages.add(subId);
        current = blocks.get(current.parent);
      }
      finalizedBlockHashes.reverse();
      return {
        event: "initialized",
        finalizedBlockHashes
      };
    };
    const unpin = (blockHash) => {
      const block = connectedBlocks.blocks.get(blockHash);
      if (block) {
        block.usages.delete(subId);
        tryRemove(blockHash);
      }
    };
    const initialEvents$ = ready$.pipe(
      mergeMap(() => {
        const { best, finalized } = connectedBlocks;
        const others = getTree(
          finalized
        ).slice(1).map(getNewBlockEvent);
        if (others.length)
          others.push({
            event: "bestBlockChanged",
            bestBlockHash: best
          });
        return [getInitialized(), ...others];
      })
    );
    return {
      blocks$: concat(initialEvents$, updates$).pipe(
        tap({
          subscribe: () => {
            activeSubscriptions.add(subId);
          },
          finalize: () => {
            activeSubscriptions.delete(subId);
          }
        }),
        share()
      ),
      getHeader: (blockHash) => connectedBlocks.blocks.get(blockHash)?.header ?? null,
      isPinned: (blockHash) => !!connectedBlocks.blocks.get(blockHash)?.usages.has(subId),
      unpin
    };
  };
  const clean = () => {
    pendingBlocks.clear();
    connectedBlocks.blocks.clear();
  };
  return {
    clean,
    upstream,
    finalized$,
    getHeader$: (hash) => {
      const block = connectedBlocks.blocks.get(hash);
      return block ? of(block) : getHeader$(hash);
    },
    hasher$
  };
};

export { getBlocks };
//# sourceMappingURL=blocks.mjs.map
