{"version":3,"file":"blocks.mjs","sources":["../../../../src/upstream/blocks/blocks.ts"],"sourcesContent":["import {\n  BestBlockChangedEvent,\n  DecentHeader,\n  InitializedEvent,\n  NewBlockEvent,\n} from \"@/types\"\nimport { UpstreamEvents } from \"./upstream-events\"\nimport {\n  concat,\n  concatMap,\n  debounceTime,\n  delay,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  share,\n  Subject,\n  take,\n  takeWhile,\n  tap,\n} from \"rxjs\"\nimport { HexString } from \"@polkadot-api/substrate-bindings\"\nimport { shareLatest } from \"@/utils/share-latest\"\n\nexport const getBlocks = ({\n  allHeads$,\n  finalized$: finalizedWire$,\n  getHeader$,\n  hasher$,\n  getRecursiveHeader,\n}: UpstreamEvents) => {\n  const connectedBlocks = {\n    blocks: new Map<\n      string,\n      DecentHeader & {\n        children: Set<string>\n        usages: Set<string>\n      }\n    >(),\n    prevFin: \"\",\n    finalized: \"\",\n    best: \"\",\n  }\n\n  const getTree = (root: string, result: string[] = []): string[] => {\n    result.push(root)\n    connectedBlocks.blocks.get(root)!.children.forEach((c) => {\n      getTree(c, result)\n    })\n    return result\n  }\n\n  const addBlock = (block: DecentHeader) => {\n    const { blocks } = connectedBlocks\n    const { hash, parent } = block\n    const me = {\n      ...block,\n      children: new Set<string>(),\n      usages: new Set<string>(),\n    }\n    blocks.set(hash, me)\n    blocks.get(parent)?.children.add(hash)\n    return me\n  }\n\n  const setBestFromFinalized = () => {\n    connectedBlocks.best = connectedBlocks.finalized\n    let bestHeight = 0\n    const { finalized, blocks } = connectedBlocks\n    getTree(finalized)\n      .map((x) => blocks.get(x)!)\n      .forEach((x) => {\n        if (x.number > bestHeight) {\n          bestHeight = x.number\n          connectedBlocks.best = x.hash\n        }\n      })\n  }\n\n  const pendingBlocks = new Map<\n    string,\n    {\n      hash: string\n      header: DecentHeader | null\n      children: Set<string>\n    }\n  >()\n\n  const trimPending = (root: string) => {\n    const desc = [...pendingBlocks.get(root)!.children]\n    pendingBlocks.delete(root)\n    desc.forEach(trimPending)\n  }\n\n  const getPendingTree = (\n    root: string,\n    result: Array<DecentHeader> = [],\n  ): Array<DecentHeader> => {\n    const me = pendingBlocks.get(root)!\n    if (!me.header) return result\n    result.push(me.header)\n    me!.children.forEach((c) => {\n      getPendingTree(c, result)\n    })\n    return result\n  }\n\n  const _newBlocks$ = new Subject<string>()\n  const onError = (e: any) => _newBlocks$.error(e)\n  const _finalized$ = finalizedWire$.pipe(\n    concatMap((header, idx) => {\n      const { hash } = header\n      if (!idx) {\n        addBlock(header)\n        connectedBlocks.finalized = connectedBlocks.best = header.hash\n      }\n      return connectedBlocks.blocks.has(hash)\n        ? of(hash)\n        : _newBlocks$.pipe(\n            filter((x) => x === hash),\n            // some of the following blocks could be prunned b/c of this finalized event.\n            // So, we have to make sure that this \"batch\" of _newBlocks has been flushed.\n            debounceTime(0),\n            take(1),\n          )\n    }),\n    share(),\n  )\n\n  allHeads$.subscribe((header) => {\n    const { parent, hash } = header\n    if (connectedBlocks.blocks.has(parent)) {\n      addBlock(header)\n      _newBlocks$.next(hash)\n    } else {\n      pendingBlocks.set(hash, {\n        hash: header.hash,\n        header,\n        children: new Set<string>(),\n      })\n\n      if (!pendingBlocks.has(parent)) {\n        pendingBlocks.set(parent, {\n          hash: parent,\n          header: null,\n          children: new Set(),\n        })\n\n        getRecursiveHeader(parent)\n          .pipe(\n            takeWhile((result) => {\n              let me = pendingBlocks.get(result.hash)\n              if (!me) return false // it was trimmed before b/c it was a prunned branch\n              me.header = result\n\n              const finalized = connectedBlocks.blocks.get(\n                connectedBlocks.finalized,\n              )\n\n              // let's check if we have to prune this\n              if (finalized && result.number <= finalized.number) {\n                while (pendingBlocks.has(me.header?.parent ?? \"\"))\n                  me = pendingBlocks.get(me.header!.parent)!\n                trimPending(me.hash)\n                return false\n              }\n\n              if (connectedBlocks.blocks.has(result.parent)) {\n                let target = connectedBlocks.blocks.get(result.parent)!\n                const diff = target.number - finalized!.number\n                for (let i = 0; i < diff; i++) {\n                  const nextTarget = connectedBlocks.blocks.get(target.parent)\n                  if (!nextTarget) break\n                  target = nextTarget\n                }\n\n                // it descends from the finalized block, all good...\n                if (target === finalized) {\n                  const pendingOnes = getPendingTree(result.hash)\n                  pendingOnes.forEach((h) => {\n                    pendingBlocks.delete(h.hash)\n                    addBlock(h)\n                    _newBlocks$.next(h.hash)\n                  })\n                } else trimPending(result.hash) // it was a pruned branch\n\n                return false\n              }\n\n              const pendingParent = pendingBlocks.get(result.parent)\n              // another subscription is loading it already\n              if (pendingParent) {\n                pendingParent.children.add(result.hash)\n                return false\n              }\n\n              pendingBlocks.set(result.parent, {\n                hash: result.parent,\n                header: null,\n                children: new Set([result.hash]),\n              })\n              return true\n            }),\n          )\n          .subscribe({ error: onError })\n      }\n      pendingBlocks.get(parent)!.children.add(hash)\n    }\n  }, onError)\n\n  const getFinalizedEvent = (): {\n    event: \"finalized\"\n    prunedBlockHashes: string[]\n    finalizedBlockHashes: string[]\n  } => {\n    const prunedBlockHashes: string[] = []\n    const finalizedBlockHashes: string[] = []\n    const { blocks, finalized, prevFin } = connectedBlocks\n\n    let current = blocks.get(finalized)!\n    let prev = blocks.get(current.parent)\n    while (prev) {\n      finalizedBlockHashes.push(current.hash)\n      prev.children.forEach((c) => {\n        if (c !== current.hash) getTree(c, prunedBlockHashes)\n      })\n      current = prev\n      if (current.hash === prevFin) break\n      prev = blocks.get(current.parent)\n    }\n    finalizedBlockHashes.reverse()\n\n    return { event: \"finalized\", prunedBlockHashes, finalizedBlockHashes }\n  }\n\n  let activeSubscriptions = new Set<string>()\n  const getNewBlockEvent = (blockHash: string) => {\n    const block = connectedBlocks.blocks.get(blockHash)!\n    activeSubscriptions.forEach((subId) => {\n      block.usages.add(subId)\n    })\n    return {\n      event: \"newBlock\" as const,\n      blockHash,\n      parentBlockHash: block.parent,\n      newRuntime: block.hasUpgrade\n        ? ({} as {\n            specName: string\n            implName: string\n            specVersion: number\n            implVersion: number\n            transactionVersion: number\n            apis: Record<string, number>\n          })\n        : null,\n    }\n  }\n\n  const tryRemove = (blockHash: string, up?: boolean) => {\n    const { blocks } = connectedBlocks\n    const block = blocks.get(blockHash)\n    if (!block || block.usages.size > 0) return\n\n    const { parent, children } = block\n    if (up !== true) children.forEach((c) => tryRemove(c, false))\n    if (up !== false) tryRemove(parent, true)\n    if (!blocks.has(parent) || !block.children.size) {\n      blocks.get(parent)?.children.delete(blockHash)\n      blocks.delete(blockHash)\n    }\n  }\n\n  const updates$ = merge(\n    _newBlocks$.pipe(\n      map((hash) => ({\n        type: \"new\" as const,\n        value: connectedBlocks.blocks.get(hash)!,\n      })),\n    ),\n    _finalized$.pipe(map((hash) => ({ type: \"fin\" as const, value: hash }))),\n  ).pipe(\n    mergeMap((x) => {\n      if (x.type === \"new\") {\n        const block = x.value\n        const { hash } = block\n        addBlock(block)\n        const result: Array<\n          | ReturnType<typeof getNewBlockEvent>\n          | { event: \"bestBlockChanged\"; bestBlockHash: string }\n        > = [getNewBlockEvent(hash)]\n        if (\n          block.number >\n          connectedBlocks.blocks.get(connectedBlocks.best)!.number\n        ) {\n          connectedBlocks.best = hash\n          result.push({ event: \"bestBlockChanged\", bestBlockHash: hash })\n        }\n        return result\n      }\n\n      connectedBlocks.prevFin = connectedBlocks.finalized\n      connectedBlocks.finalized = x.value\n      let prevBest = connectedBlocks.best\n      setBestFromFinalized()\n      const result: Array<\n        | ReturnType<typeof getFinalizedEvent>\n        | { event: \"bestBlockChanged\"; bestBlockHash: string }\n      > = [getFinalizedEvent()]\n\n      if (prevBest !== connectedBlocks.best)\n        result.unshift({\n          event: \"bestBlockChanged\",\n          bestBlockHash: connectedBlocks.best,\n        })\n      return result\n    }),\n    share(),\n  )\n\n  const ready$ = _newBlocks$.pipe(\n    filter(() => !pendingBlocks.size),\n    take(1),\n    delay(0), // allows for the first bunch of _newBlock events to settle on the latest updated state\n    map(() => null),\n    shareLatest,\n  )\n\n  const finalized$ = ready$.pipe(\n    mergeMap(() =>\n      _finalized$.pipe(\n        map((hash) => connectedBlocks.blocks.get(hash)! as DecentHeader),\n      ),\n    ),\n    shareLatest,\n  )\n\n  merge(updates$, finalized$).subscribe({\n    error: onError,\n  })\n\n  const upstream = (subId: string) => {\n    const getInitialized = () => {\n      const { blocks, finalized } = connectedBlocks\n      const finalizedBlockHashes: string[] = []\n      let current = blocks.get(finalized)\n      while (current && finalizedBlockHashes.length < 10) {\n        finalizedBlockHashes.push(current.hash)\n        current.usages.add(subId)\n        current = blocks.get(current.parent)\n      }\n      finalizedBlockHashes.reverse()\n\n      return {\n        event: \"initialized\" as const,\n        finalizedBlockHashes,\n      }\n    }\n\n    const unpin = (blockHash: string) => {\n      const block = connectedBlocks.blocks.get(blockHash)\n      if (block) {\n        block.usages.delete(subId)\n        tryRemove(blockHash)\n      }\n    }\n\n    const initialEvents$: Observable<\n      InitializedEvent | NewBlockEvent | BestBlockChangedEvent\n    > = ready$.pipe(\n      mergeMap(() => {\n        const { best, finalized } = connectedBlocks\n        const others: Array<NewBlockEvent | BestBlockChangedEvent> = getTree(\n          finalized,\n        )\n          .slice(1)\n          .map(getNewBlockEvent)\n        if (others.length)\n          others.push({\n            event: \"bestBlockChanged\" as const,\n            bestBlockHash: best,\n          })\n        return [getInitialized(), ...others]\n      }),\n    )\n\n    return {\n      blocks$: concat(initialEvents$, updates$).pipe(\n        tap({\n          subscribe: () => {\n            activeSubscriptions.add(subId)\n          },\n          finalize: () => {\n            activeSubscriptions.delete(subId)\n          },\n        }),\n        share(),\n      ),\n      getHeader: (blockHash: string) =>\n        connectedBlocks.blocks.get(blockHash)?.header ?? null,\n      isPinned: (blockHash: string) =>\n        !!connectedBlocks.blocks.get(blockHash)?.usages.has(subId),\n      unpin,\n    }\n  }\n\n  const clean = () => {\n    pendingBlocks.clear()\n    connectedBlocks.blocks.clear()\n  }\n\n  return {\n    clean,\n    upstream,\n    finalized$,\n    getHeader$: (hash: HexString): Observable<DecentHeader> => {\n      const block = connectedBlocks.blocks.get(hash)\n      return block ? of(block) : getHeader$(hash)\n    },\n    hasher$,\n  }\n}\n"],"names":["result"],"mappings":"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"}