import { getFromShittyHeader } from '../../utils/fromShittyHeader.mjs';
import { getHasherFromBlock } from '../../utils/get-hasher-from-block.mjs';
import { shareLatest } from '../../utils/share-latest.mjs';
import { withLatestFromBp } from '../../utils/with-latest-from-bp.mjs';
import { noop } from '@polkadot-api/utils';
import { Subject, mergeMap, map, pipe, Observable, concat, of } from 'rxjs';

const getUpstreamEvents = (request, request$) => {
  const firstFinHeader$ = new Subject();
  const hasher$ = firstFinHeader$.pipe(
    mergeMap(
      (h) => request$("chain_getBlockHash", [
        h.number
      ]).pipe(map(getHasherFromBlock(h)))
    ),
    shareLatest
  );
  const fromShittyHeader$ = hasher$.pipe(map(getFromShittyHeader), shareLatest);
  const toNiceHeader = pipe(
    withLatestFromBp(fromShittyHeader$),
    map(([fromShittyHeader, shitHeader]) => fromShittyHeader(shitHeader))
  );
  const getHeaders$ = (startMethod, stopMethod, isFin = false) => new Observable((observer) => {
    const onError = (e) => {
      observer.error(e);
    };
    let stop = null;
    let isFirstFin = isFin;
    request(startMethod, [], {
      onSuccess: (subId, followSub) => {
        const done = followSub(subId, {
          next: (v) => {
            if (isFirstFin) {
              isFirstFin = false;
              firstFinHeader$.next(v);
              firstFinHeader$.complete();
            }
            observer.next(v);
          },
          error: onError
        });
        const unsubscribe = () => {
          done();
          try {
            request(stopMethod, [subId], {
              onError: noop,
              onSuccess: noop
            });
          } catch {
          }
        };
        if (stop !== null) unsubscribe();
        else stop = unsubscribe;
      },
      onError
    });
    return () => {
      stop?.();
      stop = noop;
    };
  }).pipe(toNiceHeader);
  const allHeads$ = getHeaders$(
    "chain_subscribeAllHeads",
    "chain_unsubscribeAllHeads"
  );
  const finalized$ = getHeaders$(
    "chain_subscribeFinalizedHeads",
    "chain_unsubscribeFinalizedHeads",
    true
  );
  const getHeader$ = (hash) => request$("chain_getHeader", [hash]).pipe(
    toNiceHeader
  );
  const getRecursiveHeader = (hash) => getHeader$(hash).pipe(
    mergeMap(
      (header) => concat(of(header), getRecursiveHeader(header.parent))
    )
  );
  return {
    allHeads$,
    finalized$,
    hasher$,
    getRecursiveHeader,
    getHeader$
  };
};

export { getUpstreamEvents };
//# sourceMappingURL=upstream-events.mjs.map
