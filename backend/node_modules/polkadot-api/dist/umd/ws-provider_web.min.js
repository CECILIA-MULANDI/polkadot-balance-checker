(function(C,v){typeof exports=="object"&&typeof module<"u"?v(exports):typeof define=="function"&&define.amd?define(["exports"],v):(C=typeof globalThis<"u"?globalThis:C||self,v(C.papiWsProviderWeb={}))})(this,(function(C){"use strict";const v=t=>JSON.stringify({jsonrpc:"2.0",...t}),W=new Set(["v1","unstable"].map(t=>`chainHead_${t}_unfollow`)),A=t=>{let e={type:1,pending:[]};const r=s=>{if(e.type===0){const o=JSON.parse(s);if("id"in o)"result"in o&&e.onGoingRequests.get(o.id)?.type===0&&e.activeChainHeads.add(o.result),e.onGoingRequests.delete(o.id);else if("params"in o){const{subscription:n,result:a}=o.params;a?.event==="stop"&&e.activeChainHeads.delete(n)}}e.type!==2&&t(s)},i=s=>{if(e.type===2)return;if(e.type===1){e.pending.push(s);return}const o=JSON.parse(s);if(W.has(o.method)&&e.activeChainHeads.delete(o.params[0]),"id"in o){const{method:n,id:a}=o,d=n.startsWith("chainHead")?n.endsWith("follow")?{type:0,msg:s}:{type:1,id:a}:{type:2,msg:s};e.onGoingRequests.set(a,d)}e.connection.send(s)};return{send:i,disconnect:()=>{e.type!==2&&(e.type===0&&e.connection.disconnect(),e={type:2})},connect:s=>{if(e.type!==1)throw new Error("Nonesense");const{pending:o}=e,n=new Map,a=new Set;e={type:0,connection:s(r,()=>{e={type:1,pending:[]},a.forEach(f=>{r(v({params:{subscription:f,result:{event:"stop",internal:!0}}}))}),a.clear();for(const f of n.values())f.type===1?r(v({id:f.id,error:{code:-32603,message:"Internal error"},internal:!0})):i(f.msg);n.clear()}),onGoingRequests:n,activeChainHeads:a},o.forEach(i)}}},P=t=>e=>{let r=A(e);const i=()=>{t().then(s=>{if(r)r.connect((o,n)=>s(o,()=>{n(),i()}));else try{s(()=>{},()=>{}).disconnect()}catch{}},()=>{r&&setTimeout(i,0)})};return i(),{send:s=>{r?.send(s)},disconnect:()=>{r?.disconnect(),r=null}}};var y=(t=>(t[t.CONNECTING=0]="CONNECTING",t[t.CONNECTED=1]="CONNECTED",t[t.ERROR=2]="ERROR",t[t.CLOSE=3]="CLOSE",t))(y||{});const $={};["v1","unstable"].forEach(t=>{$[`chainHead_${t}_follow`]="follow",$[`chainHead_${t}_unfollow`]="unfollow"});const G=()=>({latest:Date.now(),count:0}),j=(t,e)=>{const r=new Set,i=new Map,s=new Set;let o,n=G();return Object.assign(d=>{const{send:f,disconnect:g}=t(m=>{const u=JSON.parse(m);if("id"in u){const{id:p,result:l}=u;if(p===o&&(o=void 0,l&&!l.methods.some(c=>{const[L,,H]=c.split("_");return L==="chainHead"&&H==="follow"}))){d(m),e();return}const h=i.get(p);if(h){if(i.delete(p),r.has(l)){r.delete(l);return}s.add(l);const c=s.size+i.size;if(c>2)console.warn(`Too many chainHead follow subscriptions (${c})`);else if(u.error){console.warn(`chainHead follow failed on the ${c} sub`),e(),i.set(p,h),f(h);return}}}else{const{subscription:p,result:l}=u.params;if(l?.event==="stop"){const h=Date.now()-n.latest;n.latest+=h,n.count=h<1e3?n.count+1:1,s.has(p)?s.delete(p):r.add(p)}}d(m),n.count>2&&(n=G(),e())});return{send(m){const u=JSON.parse(m);u.method==="rpc_methods"&&(o=u.id);const p=$[u.method];p==="follow"?i.set(u.id,m):p==="unfollow"&&s.delete(u.params[0]),f(m)},disconnect:g}},{cleanup:()=>{r.clear(),i.clear(),s.clear()}})},I={type:y.ERROR,event:{type:"timeout"}},S=()=>{},M={onStatusChanged:S,innerEnhancer:t=>t,timeout:5e3},k=t=>t.map(e=>typeof e=="string"?[e]:[e.uri,e.protocol]),q=(t,e)=>{const{onStatusChanged:r,innerEnhancer:i,timeout:s}={...M,...e},o=k(Array.isArray(t)?t:[t]),n=e?.websocketClass??globalThis.WebSocket;if(!n)throw new Error("Missing WebSocket class");let a=0,d,f=null,g=S,m=S;const u=j(P(async()=>{const[l,h]=f||o[a++%t.length];f=null;const c=new n(l,h),L=()=>{try{c.addEventListener("error",S,{once:!0}),c.close()}catch{}};r(d={type:y.CONNECTING,uri:l,protocols:h}),await new Promise((b,O)=>{const T=()=>{N(),b()},R=E=>{N(),E==null&&L(),console.error(`Unable to connect to ${l}${h?", protocols: "+h:""}`),r(d={type:E?y.ERROR:y.CLOSE,event:E}),setTimeout(O,E?300:0,E)},_=s!==1/0?setTimeout(()=>{N(),L(),r(d=I),O(I.event)},s):void 0,N=()=>{clearTimeout(_),c.removeEventListener("error",R),c.removeEventListener("open",T)};c.addEventListener("open",T),c.addEventListener("error",R),g=()=>{R(null)}}),r(d={type:y.CONNECTED,uri:l,protocols:h});let H;const z=i(b=>(H=b,{send:O=>{c.send(O)},disconnect:()=>{g()}}));return(b,O)=>{const T=z(b),R=w=>{typeof w.data=="string"&&H(w.data)},_=w=>D=>{console.warn(`WS halt (${w})`),r(d={type:w,event:D}),O()},N=_(y.ERROR),E=_(y.CLOSE);return c.addEventListener("message",R),c.addEventListener("error",N),c.addEventListener("close",E),g=w=>{m(),g=S,c.removeEventListener("message",R),c.removeEventListener("error",N),c.removeEventListener("close",E),L(),w&&E({}),T.disconnect()},T}}),()=>{p()});m=u.cleanup,delete u.cleanup;const p=(...l)=>{d.type!==y.CLOSE&&(l.length&&(f=l),d.type!==y.ERROR&&g(!0))};return Object.assign(u,{switch:p,getStatus:()=>d})},J=(t=>(...e)=>{let r=[],{timeout:i,innerEnhancer:s,onStatusChanged:o}=M;const[n]=e;return e.length===1&&typeof n=="object"&&!Array.isArray(n)?(r=k(n.endpoints),o=n.onStatusChanged??S,i=n.timeout??i,s=n.innerEnhancer??(a=>a)):(typeof e[1]=="function"&&(o=e[1]),Array.isArray(n)?r=k(n):(r=[[n]],e[1]&&e[1]!==o&&(r[0][1]=e[1]),e[2]&&(o=e[2]))),q(r.map(a=>a.length===1?a[0]:{uri:a[0],protocol:a[1]}),{websocketClass:t,onStatusChanged:o,timeout:i,innerEnhancer:s})})(WebSocket);C.WsEvent=y,C.getWsProvider=J}));
