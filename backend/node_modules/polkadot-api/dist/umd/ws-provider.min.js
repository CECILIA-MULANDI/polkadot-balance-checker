(function(C,a){typeof exports=="object"&&typeof module<"u"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(C=typeof globalThis<"u"?globalThis:C||self,a(C.papiWsProvider={}))})(this,(function(C){"use strict";var a=(t=>(t[t.CONNECTING=0]="CONNECTING",t[t.CONNECTED=1]="CONNECTED",t[t.ERROR=2]="ERROR",t[t.CLOSE=3]="CLOSE",t))(a||{});const G=t=>JSON.stringify({jsonrpc:"2.0",...t}),$=new Set(["v1","unstable"].map(t=>`chainHead_${t}_unfollow`)),k=t=>{let e={type:1,pending:[]};const s=n=>{if(e.type===0){const o=JSON.parse(n);if("id"in o)"result"in o&&e.onGoingRequests.get(o.id)?.type===0&&e.activeChainHeads.add(o.result),e.onGoingRequests.delete(o.id);else if("params"in o){const{subscription:r,result:y}=o.params;y?.event==="stop"&&e.activeChainHeads.delete(r)}}e.type!==2&&t(n)},c=n=>{if(e.type===2)return;if(e.type===1){e.pending.push(n);return}const o=JSON.parse(n);if($.has(o.method)&&e.activeChainHeads.delete(o.params[0]),"id"in o){const{method:r,id:y}=o,d=r.startsWith("chainHead")?r.endsWith("follow")?{type:0,msg:n}:{type:1,id:y}:{type:2,msg:n};e.onGoingRequests.set(y,d)}e.connection.send(n)};return{send:c,disconnect:()=>{e.type!==2&&(e.type===0&&e.connection.disconnect(),e={type:2})},connect:n=>{if(e.type!==1)throw new Error("Nonesense");const{pending:o}=e,r=new Map,y=new Set;e={type:0,connection:n(s,()=>{e={type:1,pending:[]},y.forEach(f=>{s(G({params:{subscription:f,result:{event:"stop",internal:!0}}}))}),y.clear();for(const f of r.values())f.type===1?s(G({id:f.id,error:{code:-32603,message:"Internal error"},internal:!0})):c(f.msg);r.clear()}),onGoingRequests:r,activeChainHeads:y},o.forEach(c)}}},q=t=>e=>{let s=k(e);const c=()=>{t().then(n=>{if(s)s.connect((o,r)=>n(o,()=>{r(),c()}));else try{n(()=>{},()=>{}).disconnect()}catch{}},()=>{s&&setTimeout(c,0)})};return c(),{send:n=>{s?.send(n)},disconnect:()=>{s?.disconnect(),s=null}}},_={};["v1","unstable"].forEach(t=>{_[`chainHead_${t}_follow`]="follow",_[`chainHead_${t}_unfollow`]="unfollow"});const I=()=>({latest:Date.now(),count:0}),J=(t,e)=>{const s=new Set,c=new Map,n=new Set;let o,r=I();return Object.assign(d=>{const{send:f,disconnect:w}=t(m=>{const u=JSON.parse(m);if("id"in u){const{id:p,result:l}=u;if(p===o&&(o=void 0,l&&!l.methods.some(i=>{const[N,,b]=i.split("_");return N==="chainHead"&&b==="follow"}))){d(m),e();return}const h=c.get(p);if(h){if(c.delete(p),s.has(l)){s.delete(l);return}n.add(l);const i=n.size+c.size;if(i>2)console.warn(`Too many chainHead follow subscriptions (${i})`);else if(u.error){console.warn(`chainHead follow failed on the ${i} sub`),e(),c.set(p,h),f(h);return}}}else{const{subscription:p,result:l}=u.params;if(l?.event==="stop"){const h=Date.now()-r.latest;r.latest+=h,r.count=h<1e3?r.count+1:1,n.has(p)?n.delete(p):s.add(p)}}d(m),r.count>2&&(r=I(),e())});return{send(m){const u=JSON.parse(m);u.method==="rpc_methods"&&(o=u.id);const p=_[u.method];p==="follow"?c.set(u.id,m):p==="unfollow"&&n.delete(u.params[0]),f(m)},disconnect:w}},{cleanup:()=>{s.clear(),c.clear(),n.clear()}})},M={type:a.ERROR,event:{type:"timeout"}},R=()=>{},j={onStatusChanged:R,innerEnhancer:t=>t,timeout:5e3},x=t=>t.map(e=>typeof e=="string"?[e]:[e.uri,e.protocol]),z=(t,e)=>{const{onStatusChanged:s,innerEnhancer:c,timeout:n}={...j,...e},o=x(Array.isArray(t)?t:[t]),r=e?.websocketClass??globalThis.WebSocket;if(!r)throw new Error("Missing WebSocket class");let y=0,d,f=null,w=R,m=R;const u=J(q(async()=>{const[l,h]=f||o[y++%t.length];f=null;const i=new r(l,h),N=()=>{try{i.addEventListener("error",R,{once:!0}),i.close()}catch{}};s(d={type:a.CONNECTING,uri:l,protocols:h}),await new Promise((L,v)=>{const T=()=>{S(),L()},O=E=>{S(),E==null&&N(),console.error(`Unable to connect to ${l}${h?", protocols: "+h:""}`),s(d={type:E?a.ERROR:a.CLOSE,event:E}),setTimeout(v,E?300:0,E)},H=n!==1/0?setTimeout(()=>{S(),N(),s(d=M),v(M.event)},n):void 0,S=()=>{clearTimeout(H),i.removeEventListener("error",O),i.removeEventListener("open",T)};i.addEventListener("open",T),i.addEventListener("error",O),w=()=>{O(null)}}),s(d={type:a.CONNECTED,uri:l,protocols:h});let b;const D=c(L=>(b=L,{send:v=>{i.send(v)},disconnect:()=>{w()}}));return(L,v)=>{const T=D(L),O=g=>{typeof g.data=="string"&&b(g.data)},H=g=>P=>{console.warn(`WS halt (${g})`),s(d={type:g,event:P}),v()},S=H(a.ERROR),E=H(a.CLOSE);return i.addEventListener("message",O),i.addEventListener("error",S),i.addEventListener("close",E),w=g=>{m(),w=R,i.removeEventListener("message",O),i.removeEventListener("error",S),i.removeEventListener("close",E),N(),g&&E({}),T.disconnect()},T}}),()=>{p()});m=u.cleanup,delete u.cleanup;const p=(...l)=>{d.type!==a.CLOSE&&(l.length&&(f=l),d.type!==a.ERROR&&w(!0))};return Object.assign(u,{switch:p,getStatus:()=>d})};C.WsEvent=a,C.getWsProvider=z}));
